//
//  _<$generatedObjectClassName$>.m
//
//	Copyright (c) 2014-2017 Sage Bionetworks
//	All rights reserved.
//
//	Redistribution and use in source and binary forms, with or without
//	modification, are permitted provided that the following conditions are met:
//	    * Redistributions of source code must retain the above copyright
//	      notice, this list of conditions and the following disclaimer.
//	    * Redistributions in binary form must reproduce the above copyright
//	      notice, this list of conditions and the following disclaimer in the
//	      documentation and/or other materials provided with the distribution.
//	    * Neither the name of Sage Bionetworks nor the names of BridgeSDk's
//		  contributors may be used to endorse or promote products derived from
//		  this software without specific prior written permission.
//
//	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//	DISCLAIMED. IN NO EVENT SHALL SAGE BIONETWORKS BE LIABLE FOR ANY
//	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// DO NOT EDIT. This file is machine-generated and constantly overwritten.
// Make changes to <$generatedObjectClassName$>.m instead.
//

#import "_<$generatedObjectClassName$>.h"<$if needsInternalHeader$>
#import "_<$generatedObjectClassName$>Internal.h"<$endif$>
#import "ModelObjectInternal.h"
#import "NSDate+SBBAdditions.h"
<$if userInfo.encrypted$>
#import "RNEncryptor.h"
#import "RNDecryptor.h"
<$endif$>
<$if userInfo.isExtendable$>
@import ObjectiveC;
<$endif$>

<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>#import "<$Relationship.destinationEntity.generatedObjectClassName$>.h"
<$endif$><$endforeach do$>

@interface _<$generatedObjectClassName$>()
<$foreach Relationship noninheritedRelationships do$>
<$if ! Relationship.userInfo.notInPONSODictionary $>
<$if Relationship.isToMany$>
// redefine relationships internally as readwrite
<$if Relationship.userInfo.isDictionaryJSON$>
@property (nonatomic, strong, readwrite) NSDictionary *<$Relationship.name$>;
<$else$>
@property (nonatomic, strong, readwrite) NSArray *<$Relationship.name$>;
<$endif$>
<$endif$>
<$endif$>
<$endforeach do$>
@end

// see xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/ios/602958/documentation/Cocoa/Conceptual/CoreData/Articles/cdAccessorMethods.html
@interface NSManagedObject (<$name$>)
<$foreach Attribute noninheritedAttributes do$>
<$if Attribute.hasDefinedAttributeType$>@property (nullable, nonatomic, retain) <$Attribute.objectAttributeType$> <$Attribute.name$>;<$endif$>
<$endforeach do$>
<$foreach Relationship noninheritedRelationships do$>
<$if Relationship.isToMany$>
<$if Relationship.isOrdered$>
@property (nullable, nonatomic, retain) NSOrderedSet<NSManagedObject *> *<$Relationship.name$>;
<$else$>
@property (nullable, nonatomic, retain) NSSet<NSManagedObject *> *<$Relationship.name$>;
<$endif$>
<$else$>
@property (nullable, nonatomic, retain) NSManagedObject *<$Relationship.name$>;
<$endif$><$endforeach do$>
<$foreach Relationship noninheritedRelationships do$>
<$if Relationship.isToMany$>- (void)add<$Relationship.name.initialCapitalString$>Object:(NSManagedObject *)value;
- (void)remove<$Relationship.name.initialCapitalString$>Object:(NSManagedObject *)value;
<$if Relationship.isOrdered$>- (void)add<$Relationship.name.initialCapitalString$>:(NSOrderedSet<NSManagedObject *> *)values;
- (void)remove<$Relationship.name.initialCapitalString$>:(NSOrderedSet<NSManagedObject *> *)values;

- (void)insertObject:(NSManagedObject *)value in<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx;
- (void)removeObjectFrom<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx;
- (void)insert<$Relationship.name.initialCapitalString$>:(NSArray<NSManagedObject *> *)value atIndexes:(NSIndexSet *)indexes;
- (void)remove<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes;
- (void)replaceObjectIn<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx withObject:(NSManagedObject *)value;
- (void)replace<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes with<$Relationship.name.initialCapitalString$>:(NSArray<NSManagedObject *> *)values;
<$else$>
- (void)add<$Relationship.name.initialCapitalString$>:(NSSet<NSManagedObject *> *)values;
- (void)remove<$Relationship.name.initialCapitalString$>:(NSSet<NSManagedObject *> *)values;
<$endif$>
<$endif$>
<$endforeach do$>
@end

@implementation _<$generatedObjectClassName$>

- (instancetype)init
{
	if ((self = [super init]))
	{
		<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$><$if Attribute.hasScalarAttributeType$><$if ! Attribute.isOptional$><$if Attribute.defaultValue$>self.<$Attribute.name$> = [NSNumber <$Attribute.scalarFactoryMethodName$><$Attribute.defaultValue$>];
		<$else$>self.<$Attribute.name$> = [NSNumber <$Attribute.scalarFactoryMethodName$>0];
		<$endif$><$endif$><$endif$><$endif$><$endforeach do$>
	}
	
	return self;
}

#pragma mark Scalar values
<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$><$if Attribute.hasScalarAttributeType$>
- (<$Attribute.scalarAttributeType$>)<$Attribute.name$>Value
{
	return [self.<$Attribute.name$> <$Attribute.scalarAccessorMethodName$>];
}

- (void)set<$Attribute.name.initialCapitalString$>Value:(<$Attribute.scalarAttributeType$>)value_
{
	self.<$Attribute.name$> = [NSNumber <$Attribute.scalarFactoryMethodName$>value_];
}
<$endif$><$endif$><$endforeach do$>


#pragma mark Dictionary representation
<$if userInfo.isExtendable$>
// Check that the selector corresponds to a property.
// Note that this doesn't handle custom getter/setter names in the declaration.
+ (objc_property_t)propertyFromSelector:(SEL)sel
{
    NSString *propertyName = NSStringFromSelector(sel);
    objc_property_t property = NULL;
    if ([propertyName hasSuffix:@":"]) {
        // setter--assume sel is of the form 'setXxxXxx:' where the property name is 'XxxXxx' or 'xxxXxx'
        // - cut off the trailing ':'
        propertyName = [[propertyName substringToIndex:propertyName.length - 1] substringFromIndex:3];
        property = class_getProperty([self class], [propertyName UTF8String]);
        if (property == NULL) {
            // dromedary-camelCase the string and try again
            propertyName = [[[propertyName substringToIndex:1] lowercaseString] stringByAppendingString:[propertyName substringFromIndex:1]];
            property = class_getProperty([self class], [propertyName UTF8String]);
        }
    } else {
        // getter--assume selector is property name
        property = class_getProperty([self class], [propertyName UTF8String]);
    }

    return property;
}

static NSString *nameForProperty(objc_property_t property)
{
    return [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];
}

static void dynamicSetterIMP(id self, SEL _cmd, id value)
{
    objc_property_t property = [[self class] propertyFromSelector:_cmd];
    if (value) {
        [[self customFields] setObject:value forKey:nameForProperty(property)];
    } else {
        [[self customFields] removeObjectForKey:nameForProperty(property)];
    }
}

static id dynamicGetterIMP(id self, SEL _cmd)
{
    objc_property_t property = [[self class] propertyFromSelector:_cmd];
    return [[self customFields] objectForKey:nameForProperty(property)];
}

// Create the custom fields container on demand.
// Note: it's an associated object and not just a property because we don't want to include it when serializing the object to JSON.
- (NSMutableDictionary *)customFields
{
    NSMutableDictionary *customFields = objc_getAssociatedObject(self, @selector(customFields));
    if (!customFields) {
        customFields = [NSMutableDictionary dictionary];
        objc_setAssociatedObject(self, @selector(customFields), customFields, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    
    return customFields;
}


// This is called by the Objective-C runtime when the object receives a message on a selector it doesn't implement.
// We're going to take advantage of that to provide setter and getter implementations for @dynamic properties
// declared in categories of <$generatedObjectClassName$>, so that all the existing machinery around marshaling and serializing
// objects to/from Bridge JSON will just work.
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    BOOL isSetter = [NSStringFromSelector(sel) hasSuffix:@":"];
    objc_property_t property = [self propertyFromSelector:sel];
    if (property) {
        if (isSetter) {
            // set the IMP for sel to dynamicSetterIMP
            class_addMethod(self, sel, (IMP)dynamicSetterIMP, "v@:@");
        } else {
            // set the IMP for sel to dynamicGetterIMP
            class_addMethod(self, sel, (IMP)dynamicGetterIMP, "@@:");
        }
    }
    
    return [super resolveInstanceMethod:sel];
}

- (NSString *)typeEncodingForPropertyName:(NSString *)propertyName
{
    objc_property_t theProperty = class_getProperty([self class], [propertyName UTF8String]);
    if (theProperty == NULL) {
        return nil;
    }

    const char *propertyAttrs = property_getAttributes(theProperty);
    NSString *propertyAttributes = [NSString stringWithCString:propertyAttrs encoding:NSUTF8StringEncoding];
    NSArray *attributeList = [propertyAttributes componentsSeparatedByString:@","];
    NSString *typeEncoding = [attributeList[0] substringFromIndex:1];

    return typeEncoding;
}

- (BOOL)typeIsNSString:(NSString *)propertyName
{
    return [[self typeEncodingForPropertyName:propertyName] isEqualToString:@"@\"NSString\""];
}
<$endif$>
<$if userInfo.isExtendable or userInfo.includesSubobject$>
- (NSArray *)originalProperties
{
    static NSArray *props;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        NSMutableArray *localProps = [@[<$foreach Attribute allAttributes do$><$if Attribute.hasDefinedAttributeType$><$if ! Attribute.userInfo.notInPONSODictionary $>@"<$Attribute.name$>", <$endif$><$endif$><$endforeach do$><$if userInfo.syntheticKeyComponentPaths.length$><$if userInfo.entityIDKeyPath.length$><$userInfo.entityIDKeyPath$>, <$endif$><$endif$><$foreach Relationship allRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if ! Relationship.userInfo.destinationEntityIDKeyPath $><$if ! Relationship.isTransient$>@"<$Relationship.name$>", <$endif$><$endif$><$endif$><$endforeach do$>@"__end_of_properties__"] mutableCopy];
        [localProps removeLastObject];
        props = [localProps copy];
    });

    return props;
}
<$endif$>

- (void)updateWithDictionaryRepresentation:(NSDictionary *)dictionary objectManager:(id<SBBObjectManagerProtocol>)objectManager
{
    [super updateWithDictionaryRepresentation:dictionary objectManager:objectManager];
    <$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$><$if ! Attribute.userInfo.notInPONSODictionary $>
<$if Attribute.isReadonly$>
    <$if Attribute.hasDateAttributeType$>
    _<$Attribute.name$> = [NSDate dateWithISO8601String:[dictionary objectForKey:@"<$Attribute.name$>"]];
    <$elseif Attribute.hasSetAttributeType$>
    _<$Attribute.name$> = [NSSet setWithArray:[dictionary objectForKey:@"<$Attribute.name$>"]];
    <$elseif Attribute.hasJSONAttributeType$>
    _<$Attribute.name$> = [dictionary objectForKey:@"<$Attribute.name$>"];
    <$elseif Attribute.hasIdAttributeType$>
    _<$Attribute.name$> = [dictionary objectForKey:@"<$Attribute.name$>"];
    <$elseif Attribute.hasTransformableAttributeType$>
    if ([<$Attribute.objectAttributeClassName$> instancesRespondToSelector:@selector(initWithDictionaryRepresentation:)]) {
        _<$Attribute.name$> = [[<$Attribute.objectAttributeClassName$> alloc] initWithDictionaryRepresentation:[dictionary objectForKey:@"<$Attribute.name$>"]];
    }
    <$else$>
    _<$Attribute.name$> = [dictionary objectForKey:@"<$Attribute.name$>"];
    <$endif$>
<$else$>
    <$if Attribute.hasDateAttributeType$>
    self.<$Attribute.name$> = [NSDate dateWithISO8601String:[dictionary objectForKey:@"<$Attribute.name$>"]];
    <$elseif Attribute.hasSetAttributeType$>
    self.<$Attribute.name$> = [NSSet setWithArray:[dictionary objectForKey:@"<$Attribute.name$>"]];
    <$elseif Attribute.hasJSONAttributeType$>
    self.<$Attribute.name$> = [dictionary objectForKey:@"<$Attribute.name$>"];
    <$elseif Attribute.hasIdAttributeType$>
    self.<$Attribute.name$> = [dictionary objectForKey:@"<$Attribute.name$>"];
    <$elseif Attribute.hasTransformableAttributeType$>
    if ([<$Attribute.objectAttributeClassName$> instancesRespondToSelector:@selector(initWithDictionaryRepresentation:)]) {
        self.<$Attribute.name$> = [[<$Attribute.objectAttributeClassName$> alloc] initWithDictionaryRepresentation:[dictionary objectForKey:@"<$Attribute.name$>"]];
    }
    <$else$>
    self.<$Attribute.name$> = [dictionary objectForKey:@"<$Attribute.name$>"];
    <$endif$>
<$endif$>
    <$elseif Attribute.name == userInfo.entityIDKeyPath && !userInfo.syntheticKeyComponentPaths $>
    // Set the entity ID key path with the key value if available, even when it's not normally
    // included in the PONSO dictionary
    NSString *keyValue = [dictionary objectForKey:@"<$Attribute.name$>"];
    if (keyValue)
        self.<$Attribute.name$> = keyValue;
    <$endif$><$endif$><$endforeach do$>
<$if userInfo.syntheticKeyComponentPaths.length$><$if userInfo.entityIDKeyPath.length$>
    NSArray *paths = [@"<$userInfo.syntheticKeyComponentPaths$>" componentsSeparatedByString:@","];
    NSString *key = @"";
    for (NSString *path in paths) {
        NSString *value = [dictionary valueForKeyPath:path];
        if (!value) {
            // probably creating in CacheManager, so just use provided synthetic key, if any
            key = [dictionary valueForKeyPath:@"<$userInfo.entityIDKeyPath$>"] ?: @"";
            break;
        }
        key = [key stringByAppendingString:value];
    }

    self.<$userInfo.entityIDKeyPath$> = key;
<$endif$><$endif$>
    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
        <$if ! Relationship.userInfo.destinationEntityIDKeyPath $><$if ! Relationship.isTransient$><$if ! Relationship.isToMany$><$if Relationship.userInfo.includedAsSubobject$>
    // If we're just creating a stub object to be populated later with actual JSON, don't try to create
    // any included subobjects at this point. We can tell because the dictionary will consist of only the
    // "type" key and nothing else.
    BOOL creatingObjectBeforePopulating = (dictionary.count == 1) && dictionary[@"type"] != nil;
        <$break$><$endif$><$endif$><$endif$><$endif$>
    <$endif$><$endforeach do$>

    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
        <$if ! Relationship.userInfo.destinationEntityIDKeyPath $><$if ! Relationship.isTransient$><$if Relationship.isToMany$>
    // overwrite the old <$Relationship.name$> relationship entirely rather than adding to it
    [self remove<$Relationship.name.initialCapitalString$>Objects];

    <$if Relationship.userInfo.isDictionaryJSON$>NSDictionary *dictionaryJSON = [dictionary objectForKey:@"<$Relationship.name$>"];
    for (id dictRepresentationForObject in dictionaryJSON.allValues)<$else$>
    for (id dictRepresentationForObject in [dictionary objectForKey:@"<$Relationship.name$>"])<$endif$>
    {
        <$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [objectManager objectFromBridgeJSON:dictRepresentationForObject];

        [self add<$Relationship.name.initialCapitalString$>Object:<$Relationship.name$>Obj];
    }<$else$>
    <$if Relationship.userInfo.includedAsSubobject$>
    NSMutableDictionary *<$Relationship.name$>Dict = nil;
    if (!creatingObjectBeforePopulating) {
        // <$Relationship.name$> is included as a subobject, meaning its fields are mingled with ours in the Bridge JSON,
        // rather than being in their own JSON dictionary under the appropriate key. So we'll create the necessary
        // JSON dictionary by copying ours, removing our own fields, and setting the type appropriately.
        <$Relationship.name$>Dict = [dictionary mutableCopy];
        NSArray *myProps = [self originalProperties];
        [<$Relationship.name$>Dict removeObjectsForKeys:myProps];
        <$Relationship.name$>Dict[@"type"] = @"<$Relationship.destinationEntity.name$>";
    }
    <$else$>
    NSDictionary *<$Relationship.name$>Dict = [dictionary objectForKey:@"<$Relationship.name$>"];
    <$endif$>
    if (<$Relationship.name$>Dict != nil)
    {
        <$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [objectManager objectFromBridgeJSON:<$Relationship.name$>Dict];
        self.<$Relationship.name$> = <$Relationship.name$>Obj;
    }<$endif$><$endif$><$endif$><$endif$><$endforeach do$>
    <$if userInfo.isExtendable$>
    // now update from the custom fields
    NSPredicate *pred = [NSPredicate predicateWithFormat:@"NOT (SELF IN %@)", self.originalProperties];
    NSArray *customProperties = [dictionary.allKeys filteredArrayUsingPredicate:pred];
    for (NSString *propertyName in customProperties) {
        if (class_getProperty([self class], [propertyName UTF8String]) == NULL) {
            // we don't know about this property (probably a new base property added on the server) so ignore it
            continue;
        }
        
        // Assuming custom properties are not readonly, and why would they be, after all?
        // ...also assume they are JSON types (NSString, NSNumber, NSNull, NSArray<JSON-types>, NSDictionary<JSON-types>)
        // ...and that they are not using custom setter names.
        id value = [dictionary objectForKey:propertyName];
        if (![self typeIsNSString:propertyName]) {
            // Custom properties are always serialized as JSON NSStrings. If it's not an NSString, assume it's not one of our known custom ones and just ignore it.
            if (![value isKindOfClass:[NSString class]]) {
                continue;
            }
            value = [NSJSONSerialization JSONObjectWithData:[value dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
        }
        NSString *camelizedProp = [[[propertyName substringToIndex:1] uppercaseString] stringByAppendingString:[propertyName substringFromIndex:1]];
        NSString *setterName = [NSString stringWithFormat:@"set%@:", camelizedProp];
        SEL setter = NSSelectorFromString(setterName);
        if ([self respondsToSelector:setter]) {
            [self performSelector:setter withObject:value];
        }
    }
    <$endif$>
}

- (NSDictionary *)dictionaryRepresentationFromObjectManager:(id<SBBObjectManagerProtocol>)objectManager
{
    NSMutableDictionary *dict = [[super dictionaryRepresentationFromObjectManager:objectManager] mutableCopy];
	<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$><$if ! Attribute.userInfo.notInPONSODictionary $>
    <$if Attribute.hasDateAttributeType$>
    [dict setObjectIfNotNil:[self.<$Attribute.name$> ISO8601String] forKey:@"<$Attribute.name$>"];
    <$elseif Attribute.hasSetAttributeType$>
    NSSortDescriptor *desc = [NSSortDescriptor sortDescriptorWithKey:@"" ascending:YES];
    [dict setObjectIfNotNil:[self.<$Attribute.name$> sortedArrayUsingDescriptors:@[desc]] forKey:@"<$Attribute.name$>"];
    <$elseif Attribute.hasJSONAttributeType$>
    [dict setObjectIfNotNil:self.<$Attribute.name$> forKey:@"<$Attribute.name$>"];
    <$elseif Attribute.hasIdAttributeType$>
    [dict setObjectIfNotNil:self.<$Attribute.name$> forKey:@"<$Attribute.name$>"];
    <$elseif Attribute.hasTransformableAttributeType$>
    if ([<$Attribute.objectAttributeClassName$> instancesRespondToSelector:@selector(dictionaryRepresentation)]) {
        [dict setObjectIfNotNil:[self.<$Attribute.name$> dictionaryRepresentation] forKey:@"<$Attribute.name$>"];
    }
    <$else$>
    [dict setObjectIfNotNil:self.<$Attribute.name$> forKey:@"<$Attribute.name$>"];
    <$endif$><$endif$><$endif$><$endforeach do$>
    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
    <$if Relationship.isToMany$>if ([self.<$Relationship.name$> count] > 0)
	{
		<$if (! Relationship.isTransient) or (Relationship.userInfo.destinationEntityIDKeyPath) $>
        <$if Relationship.userInfo.isDictionaryJSON and ! Relationship.userInfo.destinationEntityIDKeyPath$>
        NSMutableDictionary *<$Relationship.name$>RepresentationsForDictionary = [NSMutableDictionary dictionaryWithCapacity:[self.<$Relationship.name$> count]];
        <$else$>
		NSMutableArray *<$Relationship.name$>RepresentationsForDictionary = [NSMutableArray arrayWithCapacity:[self.<$Relationship.name$> count]];
        <$endif$>
		for (<$Relationship.destinationEntity.generatedObjectClassName$> *obj in self.<$Relationship.name$><$if Relationship.userInfo.isDictionaryJSON$>.allValues<$endif$>)
        {<$if Relationship.userInfo.destinationEntityIDKeyPath $>
            [<$Relationship.name$>RepresentationsForDictionary addObject:[obj valueForKeyPath:@"<$Relationship.userInfo.destinationEntityIDKeyPath$>"]];<$else$><$if Relationship.userInfo.isDictionaryJSON$>
            [<$Relationship.name$>RepresentationsForDictionary setObject:[objectManager bridgeJSONFromObject:obj] forKey:[obj valueForKeyPath:@"<$Relationship.destinationEntity.userInfo.entityIDKeyPath$>"]];<$else$>
            [<$Relationship.name$>RepresentationsForDictionary addObject:[objectManager bridgeJSONFromObject:obj]];<$endif$><$endif$>
		}
		[dict setObjectIfNotNil:<$Relationship.name$>RepresentationsForDictionary forKey:@"<$Relationship.name$>"];
		<$endif$>
	}
	<$else$>
	<$if Relationship.userInfo.destinationEntityIDKeyPath $>[dict setObjectIfNotNil:[self.<$Relationship.name$> valueForKeyPath:@"<$Relationship.userInfo.destinationEntityIDKeyPath$>"] forKey:@"<$Relationship.name$>"];
	<$else$>
    <$if ! Relationship.isTransient $>
    <$if Relationship.userInfo.includedAsSubobject$>
    // <$Relationship.name$> is included as a subobject, meaning its fields are mingled with ours in the Bridge JSON,
    // rather than being in their own JSON dictionary under the appropriate key. So we'll fetch the Bridge JSON for
    // the subobject, and then overwrite it with ours (that way the "type" key will be correct).
    NSMutableDictionary *<$Relationship.name$>JSON = [[objectManager bridgeJSONFromObject:self.<$Relationship.name$>] mutableCopy];
    [<$Relationship.name$>JSON addEntriesFromDictionary:dict];
    dict = <$Relationship.name$>JSON;
    <$else$>
    [dict setObjectIfNotNil:[objectManager bridgeJSONFromObject:self.<$Relationship.name$>] forKey:@"<$Relationship.name$>"];
    <$endif$>
	<$endif$>
	<$endif$>
	<$endif$>
    <$endif$>
	<$endforeach do$>

    <$if userInfo.isExtendable$>
    // add in the custom fields
    NSDictionary *customFields = [self customFields];
    for (NSString *propertyName in [customFields allKeys]) {
        id value = customFields[propertyName];
        if (![self typeIsNSString:propertyName]) {
            // Custom properties are always serialized as JSON NSStrings.
            NSData *jsonData = [NSJSONSerialization dataWithJSONObject:value options:0 error:nil];
            value = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
        }
        [dict setValue:value forKey:propertyName];
    }
    <$endif$>

	return [dict copy];
}

- (void)awakeFromDictionaryRepresentationInit
{
	if (self.sourceDictionaryRepresentation == nil)
		return; // awakeFromDictionaryRepresentationInit has been already executed on this object.
	
	<$foreach Relationship noninheritedRelationshipsInIDKeyPathTopologicalOrder do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if Relationship.userInfo.destinationEntityIDKeyPath $><$if Relationship.isToMany$>NSArray *<$generatedObjectClassName$>_<$Relationship.name$>IDs = [self.sourceDictionaryRepresentation objectForKey:@"<$generatedObjectClassName$>.<$Relationship.name$>"];
	for (id <$generatedObjectClassName$>_<$Relationship.name$>ID in <$generatedObjectClassName$>_<$Relationship.name$>IDs)
	{
		<$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [(_<$generatedObjectClassName$><_<$generatedObjectClassName$>> *)self fetch<$Relationship.destinationEntity.name$>ObjectWithIDFor<$Relationship.name.initialCapitalString$>Relationship:<$generatedObjectClassName$>_<$Relationship.name$>ID];
		if (<$Relationship.name$>Obj != nil)
			[self add<$Relationship.name.initialCapitalString$>Object:<$Relationship.name$>Obj];
	}
	<$else$>self.<$Relationship.name$> = [(_<$generatedObjectClassName$><_<$generatedObjectClassName$>> *)self fetch<$Relationship.destinationEntity.name$>ObjectWithIDFor<$Relationship.name.initialCapitalString$>Relationship:[self.sourceDictionaryRepresentation objectForKey:@"<$generatedObjectClassName$>.<$Relationship.name$>"]];
	<$if ! Relationship.inverseRelationship.isToMany$>self.<$Relationship.name$>.<$Relationship.inverseRelationship.name$> = (<$generatedObjectClassName$>*)self;
	<$else$>[self.<$Relationship.name$> add<$Relationship.inverseRelationship.name.initialCapitalString$>Object:(<$generatedObjectClassName$>*)self];<$endif$>
	
	<$endif$><$endif$><$endif$><$endforeach do$>


	<$foreach Relationship noninheritedRelationshipsInIDKeyPathTopologicalOrder do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if ! Relationship.isTransient$><$if Relationship.destinationEntity != Relationship.entity $><$if Relationship.isToMany$>
	for (<$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj in self.<$Relationship.name$>)
	{
		[<$Relationship.name$>Obj awakeFromDictionaryRepresentationInit];
	}
	<$else$>[self.<$Relationship.name$> awakeFromDictionaryRepresentationInit];
	<$endif$><$endif$><$endif$><$endif$><$endforeach do$>
	
	[super awakeFromDictionaryRepresentationInit];
}

#pragma mark Core Data cache

+ (NSString *)entityName
{
    return @"<$name$>";
}

- (instancetype)initWithManagedObject:(NSManagedObject *)managedObject objectManager:(id<SBBObjectManagerProtocol>)objectManager cacheManager:(id<SBBCacheManagerProtocol>)cacheManager
{
<$if userInfo.encrypted$>
    NSString *password = cacheManager.encryptionKey;
    if (password) {
        NSData *plaintext = [RNDecryptor decryptData:managedObject.<$userInfo.encrypted$> withPassword:password error:nil];
        NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:plaintext options:0 error:NULL];
        self = [self initWithDictionaryRepresentation:jsonDict objectManager:objectManager];
    } else {
        self = nil;
    }

    return self;
<$else$>
    if (self = [super initWithManagedObject:managedObject objectManager:objectManager cacheManager:cacheManager]) {
		<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$>
    <$if Attribute.hasScalarAttributeType$><$if Attribute.isUnsigned$>
        // ensure that unsigned-ness is preserved
    <$if Attribute.isReadonly$>_<$Attribute.name$> = [NSNumber <$Attribute.scalarFactoryMethodName$>[managedObject.<$Attribute.name$> <$Attribute.scalarAccessorMethodName$>]];
    <$else$>
        self.<$Attribute.name$>Value = [managedObject.<$Attribute.name$> <$Attribute.scalarAccessorMethodName$>];
    <$endif$>
    <$else$>
    <$if Attribute.isReadonly$>
        _<$Attribute.name$> = managedObject.<$Attribute.name$>;
    <$else$>
        self.<$Attribute.name$> = managedObject.<$Attribute.name$>;
    <$endif$>
    <$endif$>
    <$else$>
    <$if Attribute.isReadonly$>
        _<$Attribute.name$> = managedObject.<$Attribute.name$>;
    <$else$>
        self.<$Attribute.name$> = managedObject.<$Attribute.name$>;
    <$endif$>
    <$endif$>
		<$endif$><$endforeach do$>
		<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
            <$if ! Relationship.userInfo.destinationEntityIDKeyPath $><$if ! Relationship.isTransient$><$if Relationship.isToMany$>
		for (NSManagedObject *<$Relationship.name$>ManagedObj in managedObject.<$Relationship.name$>)
		{
            Class objectClass = [SBBObjectManager bridgeClassFromType:<$Relationship.name$>ManagedObj.entity.name];
            <$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [[objectClass alloc] initWithManagedObject:<$Relationship.name$>ManagedObj objectManager:objectManager cacheManager:cacheManager];
            if (<$Relationship.name$>Obj != nil)
            {
                [self add<$Relationship.name.initialCapitalString$>Object:<$Relationship.name$>Obj];
            }
		}<$else$>NSManagedObject *<$Relationship.name$>ManagedObj = managedObject.<$Relationship.name$>;
        Class <$Relationship.name$>Class = [SBBObjectManager bridgeClassFromType:<$Relationship.name$>ManagedObj.entity.name];
        <$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [[<$Relationship.name$>Class alloc] initWithManagedObject:<$Relationship.name$>ManagedObj objectManager:objectManager cacheManager:cacheManager];
        if (<$Relationship.name$>Obj != nil)
        {
          self.<$Relationship.name$> = <$Relationship.name$>Obj;
        }<$endif$><$endif$><$endif$><$endif$><$endforeach do$>
    }

    return self;
<$endif$>
}

- (NSManagedObject *)createInContext:(NSManagedObjectContext *)cacheContext withObjectManager:(id<SBBObjectManagerProtocol>)objectManager cacheManager:(id<SBBCacheManagerProtocol>)cacheManager
{
    NSManagedObject *managedObject = [NSEntityDescription insertNewObjectForEntityForName:@"<$name$>" inManagedObjectContext:cacheContext];
    [self updateManagedObject:managedObject withObjectManager:objectManager cacheManager:cacheManager];

    // Calling code will handle saving these changes to cacheContext.

    return managedObject;
}

<$if userInfo[@"entityIDKeyPath"]$>
- (NSManagedObject *)saveToContext:(NSManagedObjectContext *)cacheContext withObjectManager:(id<SBBObjectManagerProtocol>)objectManager cacheManager:(id<SBBCacheManagerProtocol>)cacheManager
{
    NSManagedObject *managedObject = [cacheManager cachedObjectForBridgeObject:self inContext:cacheContext];
    if (managedObject) {
        [self updateManagedObject:managedObject withObjectManager:objectManager cacheManager:cacheManager];
    }

    // Calling code will handle saving these changes to cacheContext.

    return managedObject;
}
<$endif$>

- (void)updateManagedObject:(NSManagedObject *)managedObject withObjectManager:(id<SBBObjectManagerProtocol>)objectManager cacheManager:(id<SBBCacheManagerProtocol>)cacheManager
{
    <$if userInfo.encrypted$>NSDictionary *jsonDict = [objectManager bridgeJSONFromObject:self];
    NSError *error;
    NSData *plaintext = [NSJSONSerialization dataWithJSONObject:jsonDict options:0 error:&error];
    NSString *password = cacheManager.encryptionKey;
    if (password && !error) {
        NSData *ciphertext = [RNEncryptor encryptData:plaintext withSettings:kRNCryptorAES256Settings password:password error:&error];
        if (!error) {
            managedObject.<$userInfo.encrypted$> = ciphertext;
        }
    }
    <$if userInfo.entityIDKeyPath$>
    // fill in the key used for caching this object type so we can still use the usual
    // fetch requests with predicates to find it in CoreData in spite of being encrypted.
    id keyValue = ((id)self.<$userInfo.entityIDKeyPath$> == [NSNull null]) ? nil : self.<$userInfo.entityIDKeyPath$>;
    [managedObject setValue:keyValue forKey:@"<$userInfo.entityIDKeyPath$>"];
    <$endif$>
    <$else$>[super updateManagedObject:managedObject withObjectManager:objectManager cacheManager:cacheManager];
    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>NSManagedObjectContext *cacheContext = managedObject.managedObjectContext;<$break$><$endif$><$endforeach do$>
	<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$>
    managedObject.<$Attribute.name$> = ((id)self.<$Attribute.name$> == [NSNull null]) ? nil : self.<$Attribute.name$>;
	<$endif$><$endforeach do$>
    <$foreach Relationship noninheritedRelationships do$>
    <$if ! Relationship.userInfo.notInPONSODictionary $>
    <$if Relationship.isToMany$>
    <$if ! Relationship.isTransient $>// first make a copy of the existing relationship collection, to iterate through while mutating original
    <$if Relationship.isOrdered$>NSOrderedSet<$else$>NSSet<$endif$> *<$Relationship.name$>Copy = [managedObject.<$Relationship.name$> copy];

    // now remove all items from the existing relationship
    <$if Relationship.isOrdered$>// to work pre-iOS 10, we have to work around this issue: http://stackoverflow.com/questions/7385439/exception-thrown-in-nsorderedset-generated-accessors
    NSMutableOrderedSet *working<$Relationship.name.initialCapitalString$>Set = [managedObject mutableOrderedSetValueForKey:NSStringFromSelector(@selector(<$Relationship.name$>))];
    [working<$Relationship.name.initialCapitalString$>Set removeAllObjects];
    <$else$>[managedObject remove<$Relationship.name.initialCapitalString$>:managedObject.<$Relationship.name$>];
    <$endif$>

    // now put the "new" items, if any, into the relationship
    if ([self.<$Relationship.name$> count] > 0) {
		for (<$Relationship.destinationEntity.generatedObjectClassName$> *obj in self.<$Relationship.name$><$if Relationship.userInfo.isDictionaryJSON$>.allValues<$endif$>) {
            NSManagedObject *relMo = nil;
            if ([obj isDirectlyCacheableWithContext:cacheContext]) {
                // get it from the cache manager
                relMo = [cacheManager cachedObjectForBridgeObject:obj inContext:cacheContext];
            }
            if (!relMo) {
                // sub object is not directly cacheable, or not currently cached, so create it before adding
                relMo = [obj createInContext:cacheContext withObjectManager:objectManager cacheManager:cacheManager];
            }
            <$if Relationship.isOrdered$>
            [working<$Relationship.name.initialCapitalString$>Set addObject:relMo];
            <$else$>
            [managedObject add<$Relationship.name.initialCapitalString$>Object:relMo];
            <$endif$>
        }
	}

    // now release any objects that aren't still in the relationship (they will be deleted when they no longer belong to any to-many relationships)
    for (NSManagedObject *relMo in <$Relationship.name$>Copy) {
        <$if Relationship.inverseRelationship.isToMany$>if (![[relMo valueForKey:@"<$Relationship.inverseRelationship.name$>"] count]) {
        <$else$>if (![relMo valueForKey:@"<$Relationship.inverseRelationship.name$>"]) {
        <$endif$>   [self releaseManagedObject:relMo inContext:cacheContext];
        }
    }

    // ...and let go of the collection copy
    <$Relationship.name$>Copy = nil;
    <$endif$>
    <$else$>
    <$if ! Relationship.isTransient $>
    <$if Relationship.destinationEntity.userInfo.entityIDKeyPath$>// destination entity <$Relationship.destinationEntity.name$> is directly cacheable, so get it from cache manager
    NSManagedObject *relMo<$Relationship.name.initialCapitalString$> = [cacheManager cachedObjectForBridgeObject:self.<$Relationship.name$> inContext:cacheContext];
    <$else$>// destination entity <$Relationship.destinationEntity.name$> is not directly cacheable, so delete it and create the replacement
    if (managedObject.<$Relationship.name$>) {
        [cacheContext deleteObject:managedObject.<$Relationship.name$>];
    }
    NSManagedObject *relMo<$Relationship.name.initialCapitalString$> = [self.<$Relationship.name$> createInContext:cacheContext withObjectManager:objectManager cacheManager:cacheManager];
    <$endif$>
    [managedObject set<$Relationship.name.initialCapitalString$>:relMo<$Relationship.name.initialCapitalString$>];
	<$endif$>
	<$endif$>
    <$endif$>
	<$endforeach do$>
    <$endif$>

    // Calling code will handle saving these changes to cacheContext.
}

#pragma mark Direct access

<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if Relationship.isToMany$>
- (void)add<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_ settingInverse: (BOOL) setInverse
{
    if (self.<$Relationship.name$> == nil)
	{
	    <$if Relationship.isTransient$>
	    CFArrayCallBacks callbacks = {0, NULL, NULL, CFCopyDescription, CFEqual};
      self.<$Relationship.name$> = (NSMutableArray*)CFArrayCreateMutable(0, 0, &callbacks);
	    <$else$>
        <$if Relationship.userInfo.isDictionaryJSON$>
        self.<$Relationship.name$> = [NSMutableDictionary dictionary];
        <$else$>
		self.<$Relationship.name$> = [NSMutableArray array];
        <$endif$>
		<$endif$>
	}
		
    <$if Relationship.userInfo.isDictionaryJSON$>
    [(NSMutableDictionary *)self.<$Relationship.name$> setObject:value_ forKey:[value_ valueForKeyPath:@"<$Relationship.destinationEntity.userInfo.entityIDKeyPath$>"]];
    <$else$>
	[(NSMutableArray *)self.<$Relationship.name$> addObject:value_];
    <$endif$>
	<$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
	    [value_ set<$Relationship.inverseRelationship.name.initialCapitalString$>: (<$generatedObjectClassName$>*)self settingInverse: NO];
	}<$endif$><$endif$><$endif$>
}

- (void)add<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_
{
    [self add<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_ settingInverse: YES];
}

- (void)remove<$Relationship.name.initialCapitalString$>Objects
{
	<$if Relationship.isTransient$>
    CFArrayCallBacks callbacks = {0, NULL, NULL, CFCopyDescription, CFEqual};
      self.<$Relationship.name$> = (NSMutableArray*)CFArrayCreateMutable(0, 0, &callbacks);
    <$else$>
    <$if Relationship.userInfo.isDictionaryJSON$>
    self.<$Relationship.name$> = [NSMutableDictionary dictionary];
    <$else$>
    self.<$Relationship.name$> = [NSMutableArray array];
    <$endif$>
	<$endif$>
}

- (void)remove<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_ settingInverse: (BOOL) setInverse
{
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
        [value_ set<$Relationship.inverseRelationship.name.initialCapitalString$>: nil settingInverse: NO];
    }<$endif$><$endif$><$endif$>
<$if Relationship.userInfo.isDictionaryJSON$>
    [(NSMutableDictionary *)self.<$Relationship.name$> removeObjectForKey:[value_ valueForKeyPath:@"<$Relationship.destinationEntity.userInfo.entityIDKeyPath$>"]];
<$else$>
    [(NSMutableArray *)self.<$Relationship.name$> removeObject:value_];
<$endif$>
}

- (void)remove<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_
{
    [self remove<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_ settingInverse: YES];
}
<$if Relationship.isOrdered$>
- (void)insertObject:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value in<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx {
    [self insertObject:value in<$Relationship.name.initialCapitalString$>AtIndex:idx settingInverse:YES];
}

<$if ! Relationship.userInfo.isDictionaryJSON$>
- (void)insertObject:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value in<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx settingInverse:(BOOL)setInverse {

    [(NSMutableArray *)self.<$Relationship.name$> insertObject:value atIndex:idx];
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
    [value set<$Relationship.inverseRelationship.name.initialCapitalString$>:(<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$endif$><$endif$><$endif$>
}

- (void)removeObjectFrom<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx {
    [self removeObjectFrom<$Relationship.name.initialCapitalString$>AtIndex:idx settingInverse:YES];
}

- (void)removeObjectFrom<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx settingInverse:(BOOL)setInverse {
    <$Relationship.destinationEntity.generatedObjectClassName$> *object = [self.<$Relationship.name$> objectAtIndex:idx];
    [self remove<$Relationship.name.initialCapitalString$>Object:object settingInverse:YES];
}

- (void)insert<$Relationship.name.initialCapitalString$>:(NSArray *)value atIndexes:(NSIndexSet *)indexes {
    [self insert<$Relationship.name.initialCapitalString$>:value atIndexes:indexes settingInverse:YES];
}

- (void)insert<$Relationship.name.initialCapitalString$>:(NSArray *)value atIndexes:(NSIndexSet *)indexes settingInverse:(BOOL)setInverse {
    [(NSMutableArray *)self.<$Relationship.name$> insertObjects:value atIndexes:indexes];
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
        for (<$Relationship.destinationEntity.generatedObjectClassName$>* object in value) {
            [object set<$Relationship.inverseRelationship.name.initialCapitalString$>:(<$generatedObjectClassName$>*)self settingInverse: NO];
        }
    }<$endif$><$endif$><$endif$>
}

- (void)remove<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes {
    [self remove<$Relationship.name.initialCapitalString$>AtIndexes:indexes settingInverse:YES];
}

- (void)remove<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes settingInverse:(BOOL)setInverse {
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
    NSArray *objectsRemoved = [(NSMutableArray *)self.<$Relationship.name$> objectsAtIndexes:indexes];
        for (<$Relationship.destinationEntity.generatedObjectClassName$>* object in objectsRemoved) {
            [object set<$Relationship.inverseRelationship.name.initialCapitalString$>:nil settingInverse: NO];
        }
    }<$endif$><$endif$><$endif$>
    [(NSMutableArray *)self.<$Relationship.name$> removeObjectsAtIndexes:indexes];
}

- (void)replaceObjectIn<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx withObject:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value {
    [self replaceObjectIn<$Relationship.name.initialCapitalString$>AtIndex:idx withObject:value settingInverse:YES];
}

- (void)replaceObjectIn<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx withObject:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value settingInverse:(BOOL)setInverse {
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
    <$Relationship.destinationEntity.generatedObjectClassName$>* objectReplaced = [(NSMutableArray *)self.<$Relationship.name$> objectAtIndex:idx];
    [objectReplaced set<$Relationship.inverseRelationship.name.initialCapitalString$>:nil settingInverse: NO];
    [value set<$Relationship.inverseRelationship.name.initialCapitalString$>:(<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$endif$><$endif$><$endif$>
    [(NSMutableArray *)self.<$Relationship.name$> replaceObjectAtIndex:idx withObject:value];
}

- (void)replace<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes with<$Relationship.name.initialCapitalString$>:(NSArray *)value {
    [self replace<$Relationship.name.initialCapitalString$>AtIndexes:indexes with<$Relationship.name.initialCapitalString$>:value settingInverse:YES];
}

- (void)replace<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes with<$Relationship.name.initialCapitalString$>:(NSArray *)value settingInverse:(BOOL)setInverse {
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
    NSArray *objectsReplaced = [(NSMutableArray *)self.<$Relationship.name$> objectsAtIndexes:indexes];
        for (<$Relationship.destinationEntity.generatedObjectClassName$>* object in objectsReplaced) {
            [object set<$Relationship.inverseRelationship.name.initialCapitalString$>:nil settingInverse: NO];
        }
        for (<$Relationship.destinationEntity.generatedObjectClassName$>* object in value) {
            [object set<$Relationship.inverseRelationship.name.initialCapitalString$>:(<$generatedObjectClassName$>*)self settingInverse: NO];
        }
    }<$endif$><$endif$><$endif$>
    [(NSMutableArray *)self.<$Relationship.name$> replaceObjectsAtIndexes:indexes withObjects:value];
}
<$endif$>
<$endif$>
<$endif$><$endif$><$endforeach do$>

<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if ! Relationship.isToMany$>
- (void) set<$Relationship.name.initialCapitalString$>: (<$Relationship.destinationEntity.generatedObjectClassName$>*) <$Relationship.name$>_ settingInverse: (BOOL) setInverse
{
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if Relationship.inverseRelationship.isToMany$>if (<$Relationship.name$>_ == nil) {
        [_<$Relationship.name$> remove<$Relationship.inverseRelationship.name.initialCapitalString$>Object: (<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$else$>if (<$Relationship.name$>_ == nil) {
        [_<$Relationship.name$> set<$Relationship.inverseRelationship.name.initialCapitalString$>: nil settingInverse: NO];
    }
    <$endif$><$endif$><$endif$>
    _<$Relationship.name$> = <$Relationship.name$>_;

    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
        [_<$Relationship.name$> add<$Relationship.inverseRelationship.name.initialCapitalString$>Object: (<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$else$>if (setInverse == YES) {
        [_<$Relationship.name$> set<$Relationship.inverseRelationship.name.initialCapitalString$>: (<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$endif$><$endif$><$endif$>
}

- (void) set<$Relationship.name.initialCapitalString$>: (<$Relationship.destinationEntity.generatedObjectClassName$>*) <$Relationship.name$>_
{
    [self set<$Relationship.name.initialCapitalString$>: <$Relationship.name$>_ settingInverse: YES];
}

- (<$Relationship.destinationEntity.generatedObjectClassName$>*) <$Relationship.name$>
{
    return _<$Relationship.name$>;
}

<$endif$><$endif$><$endforeach do$>

<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if ! Relationship.isToMany$>@synthesize <$Relationship.name$> = _<$Relationship.name$>;<$endif$><$endif$><$endforeach do$>

@end
